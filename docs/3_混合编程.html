<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>混合编程 | Using Swift with Cocoa and Objective-C (Swift 2.2 Pre-release) 中文版</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Swift Cocoa Object-c 中文版">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.852b9951.js" as="script"><link rel="preload" href="/assets/js/2.a9a511c7.js" as="script"><link rel="preload" href="/assets/js/7.db9f1311.js" as="script"><link rel="prefetch" href="/assets/js/10.e9682f91.js"><link rel="prefetch" href="/assets/js/11.1d9812eb.js"><link rel="prefetch" href="/assets/js/12.f7533ecc.js"><link rel="prefetch" href="/assets/js/3.6db78773.js"><link rel="prefetch" href="/assets/js/4.50e805ad.js"><link rel="prefetch" href="/assets/js/5.3c6d5bd7.js"><link rel="prefetch" href="/assets/js/6.52cae17e.js"><link rel="prefetch" href="/assets/js/8.4631b529.js"><link rel="prefetch" href="/assets/js/9.84aab410.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Using Swift with Cocoa and Objective-C (Swift 2.2 Pre-release) 中文版</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">介绍</a></li><li><a href="/0_目录.html" class="sidebar-link">目录</a></li><li><a href="/1_开始.html" class="sidebar-link">开始</a></li><li><a href="/2_互操作性.html" class="sidebar-link">互操作性</a></li><li><a href="/3_混合编程.html" class="active sidebar-link">混合编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3_混合编程.html#在同一个项目中使用swift和objective-c" class="sidebar-link">在同一个项目中使用Swift和Objective-C</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3_混合编程.html#混合编程概览" class="sidebar-link">混合编程概览</a></li><li class="sidebar-sub-header"><a href="/3_混合编程.html#从同一个应用编译目标中导入代码" class="sidebar-link">从同一个应用编译目标中导入代码</a></li><li class="sidebar-sub-header"><a href="/3_混合编程.html#从同一个框架编译目标中导入代码" class="sidebar-link">从同一个框架编译目标中导入代码</a></li><li class="sidebar-sub-header"><a href="/3_混合编程.html#导入外置框架" class="sidebar-link">导入外置框架</a></li><li class="sidebar-sub-header"><a href="/3_混合编程.html#在objective-c中使用swift" class="sidebar-link">在Objective-C中使用Swift</a></li><li class="sidebar-sub-header"><a href="/3_混合编程.html#覆盖objective-c接口中的swift名字" class="sidebar-link">覆盖Objective-C接口中的Swift名字</a></li><li class="sidebar-sub-header"><a href="/3_混合编程.html#使objective-c的接口在swift中不可用" class="sidebar-link">使Objective-C的接口在Swift中不可用</a></li><li class="sidebar-sub-header"><a href="/3_混合编程.html#改进objective-c的声明" class="sidebar-link">改进Objective-C的声明</a></li><li class="sidebar-sub-header"><a href="/3_混合编程.html#给产品模块命名" class="sidebar-link">给产品模块命名</a></li><li class="sidebar-sub-header"><a href="/3_混合编程.html#问题诊断和注意事项" class="sidebar-link">问题诊断和注意事项</a></li></ul></li></ul></li><li><a href="/4_迁移到Swift.html" class="sidebar-link">迁移到Swift</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="混合编程"><a href="#混合编程" class="header-anchor">#</a> 混合编程</h1> <h2 id="在同一个项目中使用swift和objective-c"><a href="#在同一个项目中使用swift和objective-c" class="header-anchor">#</a> 在同一个项目中使用Swift和Objective-C</h2> <p>Swift与Objective-C的兼容性，能让你创建一个同时包含这两种语言代码文件的项目。你可以使用这个特性，也就是<em>混合编程</em>（mix and match），来编写混合语言（mixed-language）代码的应用。使用混合编程，你可以使用最新的Swift的特性实现程序的部分功能，同时把这部分功能整合回你已有的Objective-C代码库（codebase）。</p> <h3 id="混合编程概览"><a href="#混合编程概览" class="header-anchor">#</a> 混合编程概览</h3> <p>Objective-C和Swift的文件可以在同一个项目中共存，不论该项目最初是一个Objective-C项目还是Swift项目。你可以为现存的项目添加另一种语言的文件。这种自然的工作流使得创建混合语言的应用和框架，跟创建单一语言的应用或框架一样简单。</p> <p>处理混合语言项目（target）的过程，取决于是应用项目还是框架项目而略有差异。在同一个项目中使用两种语言的基本文件导入模型参见下图，后续的章节中将对细节进行详述。</p> <p>（译者按：target是一个编译目标。通常，一个项目会包含一个或多个编译目标。为了语句通顺，在翻译target的时候，为了便于理解，在不会产生误解的时候，我会根据语境，把target翻译成编译目标或项目。）</p> <p><img src="/assets/img/pic_3.1.cbc21a56.png" alt="文件导入模型"></p> <p>（译者按：umbrella header这里翻译为综合头文件。unbrella header是框架中使用的头文件，这个头文件用来包含框架中其他头文件，用来综合地暴露框架的接口。）</p> <h3 id="从同一个应用编译目标中导入代码"><a href="#从同一个应用编译目标中导入代码" class="header-anchor">#</a> 从同一个应用编译目标中导入代码</h3> <p>如果你在编写混合语言的应用，你可能需要在Swift中访问Objective-C代码，或在Objective-C中访问Swift代码。这个过程在本节中讨论，适用于非框架（non-framework）的编译目标。</p> <h4 id="把objective-c导入swift"><a href="#把objective-c导入swift" class="header-anchor">#</a> 把Objective-C导入Swift</h4> <p>要在Swift代码的编译目标中导入一系列Objective-C文件，你可以使用<em>Objective-C桥接头文件</em>，将这些文件暴露给Swift。当你向一个已有的Objective-C应用中增加Swift文件，或向一个已有的Swift应用中增加Objective-C文件的时候，Xcode会引导你创建这个头文件。</p> <p><img src="/assets/img/pic_3.2.7f8d1a32.png" alt="创建桥接头文件"></p> <p>如果你确认，Xcode会在创建Objective-C文件的同时创建这个头文件，并用产品模块（product module）名加上<code>&quot;-Bridging-Header.h&quot;</code>作为文件名。（你将在<a href="#%E7%BB%99%E4%BA%A7%E5%93%81%E6%A8%A1%E5%9D%97%E5%91%BD%E5%90%8D">给产品模块命名</a>章节学到更多关于产品模块名的信息。）</p> <p>你也可以通过 File &gt; New &gt; File &gt; (iOS，watchOS，tvOS或OS X) &gt; Source &gt; Header File 自己手工创建一个桥接头文件。</p> <p>你需要自己编辑这个头文件，把Objective-C代码暴露给Swift代码。</p> <h5 id="把同一个编译目标中的objective-c代码导入swift"><a href="#把同一个编译目标中的objective-c代码导入swift" class="header-anchor">#</a> 把同一个编译目标中的Objective-C代码导入Swift</h5> <ol><li><p>在你的Objective-C桥接头文件中导入所有你想暴露给Swift的Objective-C头文件。例如：</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">&quot;XYZCustomCell.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">&quot;XYZCustomView.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">&quot;XYZCustomViewController.h&quot;</span></span>
</code></pre></div></li> <li><p>在编译设置（Build Settings）里，在Swift Compiler - Code Generation部分，确保Objective-C Bridging Header这个编译设置包含了桥接头文件的路径。</p> <p>路径必需是相对于项目的路径，这和Build Settings里设置Info.plist时的要求是一样的。在大多数情况下，你无需修改这个设置。</p></li></ol> <p>在桥接头文件中列出的所有Objective-C头文件都将对Swift可见。Objecitve-C的功能会对同一个编译目标中的所有Swift文件都可用，而无需使用任何导入（import）语句。你可以像使用系统类那样，用Swift的语法调用你自己的Objective-C代码。</p> <div class="language-swift extra-class"><pre class="language-swift"><code><span class="token keyword">let</span> cell <span class="token operator">=</span> <span class="token function">XYZCustomCell</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
myCell<span class="token punctuation">.</span>subtitle <span class="token operator">=</span> <span class="token string">&quot;A custom cell&quot;</span>
</code></pre></div><h4 id="把swift导入objective-c"><a href="#把swift导入objective-c" class="header-anchor">#</a> 把Swift导入Objective-C</h4> <p>当你把Swift代码导入Objective-C时，你是靠<em>Xcode生成的头文件</em>把它们暴露给Objective-C的。这个自动生成的文件是一个Objective-C头文件，声明了编译目标中Swift代码的接口。你可以认为它是Swift代码的综合头文件（umbrella header）。这个头文件的名字是产品模块名加上<code>&quot;-Swift.h&quot;</code>。（你将在<a href="#%E7%BB%99%E4%BA%A7%E5%93%81%E6%A8%A1%E5%9D%97%E5%91%BD%E5%90%8D">给产品模块命名</a>章节学到更多关于产品模块名的信息。）</p> <p>默认条件下，生成的头文件包含了Swift文件中有<code>public</code>修饰符的声明。如果应用编译目标包含了Objective-C桥接头文件，那么这个文件还包含所有使用<code>internal</code>修饰符的声明。使用<code>private</code>修饰符标记的声明不会出现在生成的头文件中。除非显式地使用<code>@IBAction</code>，<code>@IBOutlet</code>或<code>@objc</code>做了标记，否则私有的声明不会暴露给Objective-C。如果应用编译目标启用了测试，并且产品模块的导入语句加上了<code>@testable</code>修饰符，那么单元测试编译目标可以访问任何用<code>internal</code>修饰符标记的声明，就好像它们是用<code>public</code>修饰符标记的一样。</p> <p>要了解更多关于访问控制修饰符的信息，请参考“Swift编程语言（Swift 2.2版）”的“访问控制”章节。</p> <p>要创建生成的头文件，你不需要做任何事--只需在要使用它的Objective-C代码中导入这个头文件。需要注意的是，生成的头文件中的Swift接口会包含所有在你的Swift代码中用到的Objective-C类型的引用，因此，如果你在Swift代码中使用了你自己创建的的Objective-C类，那么请确保在Objective-C的<code>.m</code>文件导入Swift生成的头文件之前，先导入自定义类型的Objective-C头文件。</p> <h5 id="把同一个编译目标中的swift代码导入objective-c"><a href="#把同一个编译目标中的swift代码导入objective-c" class="header-anchor">#</a> 把同一个编译目标中的Swift代码导入Objective-C</h5> <ul><li><p>使用如下语法，替换成合适的文件名，可以把同一个编译目标中的Swift代码导入Objective-C的<code>.m</code>文件。</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">&quot;ProductModuleName-Swift.h&quot;</span></span>
</code></pre></div></li></ul> <p>编译目标中的Swift文件将会对包含上述导入语句的Objective-C的<code>.m</code>文件可见。要了解更多关于如何在Objective-C代码中使用Swift的信息，请参考<a href="%E5%9C%A8Objective-C%E4%B8%AD%E4%BD%BF%E7%94%A8Swift">在Objective-C中使用Swift</a>章节。</p> <table><tr><td> </td><td><strong>导入至Swift</strong></td><td><strong>导入至Objecitve-C</strong></td></tr> <tr><td>Swift代码</td><td>无需导入语句</td><td><code>#import &quot;ProductModuleName-Swift.h&quot;</code></td></tr> <tr><td>Objective-C代码</td><td>无需导入语句；需要Objecitve-C桥接头文件</td><td><code>#import &quot;Header.h&quot;</code></td></tr></table> <h3 id="从同一个框架编译目标中导入代码"><a href="#从同一个框架编译目标中导入代码" class="header-anchor">#</a> 从同一个框架编译目标中导入代码</h3> <p>如果你编写混合语言的框架，那么你就可能需要在Objective-C代码中访问Swift或在Swift代码中访问Objective-C。</p> <h4 id="把objective-c导入swift-2"><a href="#把objective-c导入swift-2" class="header-anchor">#</a> 把Objective-C导入Swift</h4> <p>要在Swift代码的框架编译目标中导入一系列Objective-C文件，你需要使用框架的Objective-C综合头文件（umbrella header）导入这些文件。</p> <h5 id="把同一个框架中的objective-c代码导入swift"><a href="#把同一个框架中的objective-c代码导入swift" class="header-anchor">#</a> 把同一个框架中的Objective-C代码导入Swift</h5> <ol><li><p>在Build Settings中的Packaging部分，确保框架编译目标的Define Module选项设置为了“YES”。</p></li> <li><p>在综合头文件中，导入所有你要暴露给Swift的Objective-C头文件。例如：</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>XYZ<span class="token operator">/</span>XYZCustomCell<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>XYZ<span class="token operator">/</span>XYZCustomView<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>XYZ<span class="token operator">/</span>XYZCustomViewController<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>
</code></pre></div></li> <li><p>Swift能看到所有公开暴露在综合头文件中的头文件，框架中的Objective-C文件会自动对框架中的所有Swift文件可用，无需额外的导入声明。你可以像使用系统类那样，用Swift的语法调用你自己的Objective-C代码。</p></li></ol> <div class="language-swift extra-class"><pre class="language-swift"><code><span class="token keyword">let</span> myOtherCell <span class="token operator">=</span> <span class="token function">XYZCustomCell</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
myOtherCell<span class="token punctuation">.</span>subtitle <span class="token operator">=</span> <span class="token string">&quot;Another custom cell&quot;</span>
</code></pre></div><h4 id="把swift导入objective-c-2"><a href="#把swift导入objective-c-2" class="header-anchor">#</a> 把Swift导入Objective-C</h4> <p>要在同一框架目标中的Objective-C代码中使用Swift文件，你无需在综合头文件中导入任何文件。你只需在任何需要使用Swift代码的Objective-C的<code>.m</code>文件中导入Xcode生成的头文件。</p> <p>因为框架目标的生成的头文件的是框架公开接口的一部分，因此只有用<code>public</code>修饰符标记的声明才会出现在框架目标的生成的头文件中。如果Swift的类是派生自Objective-C的类，那么你还可以在框架中的Objective-C能访问用<code>internal</code>修饰符标记的属性和方法。要了解更多关于访问控制修饰符的信息，请参考“Swift编程语言（Swift 2.2版）”的“访问控制”章节。</p> <h5 id="把同一个编译框架中的swift代码导入objective-c"><a href="#把同一个编译框架中的swift代码导入objective-c" class="header-anchor">#</a> 把同一个编译框架中的Swift代码导入Objective-C</h5> <ol><li><p>在Build Settings中的Packaging部分，确保框架编译目标的Define Module选项设置为了“YES”。</p></li> <li><p>使用如下语法，替换成合适的文件名，可以把同一个框架中的Swift代码导入Objective-C的<code>.m</code>文件。</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>ProductName<span class="token operator">/</span>ProductModuleName<span class="token operator">-</span>Swift<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>
</code></pre></div></li></ol> <p>框架中的Swift文件将会对含有上述导入语句的Objective-C的<code>.m</code>文件可见。要了解更多关于如何在Objective-C代码中使用Swift的信息，请参考<a href="#%E5%9C%A8objective-c%E4%B8%AD%E4%BD%BF%E7%94%A8swift">在Objective-C中使用Swift</a>章节。</p> <table><tr><td> </td><td><strong>导入至Swift</strong></td><td><strong>导入至Objecitve-C</strong></td></tr> <tr><td>Swift代码</td><td>无需导入语句</td><td><code>#import &lt;ProductName/ProductModuleName-Swift.h&gt;</code></td></tr> <tr><td>Objective-C代码</td><td>无需导入语句；需要综合头文件</td><td><code>#import &quot;Header.h&quot;</code></td></tr></table> <h3 id="导入外置框架"><a href="#导入外置框架" class="header-anchor">#</a> 导入外置框架</h3> <p>你可以在纯Objective-C代码库（codebase）、纯Swift代码库，或混合语言的代码库中导入外置框架（external framework）。无论外置框架是用一种语言编写，还是同时包含了两种语言的文件，导入的过程都是一样的。当你导入外置框架的时候，请确保框架的Build Settings中的Define Module的值设置成了“Yes”。</p> <p>你可以在其他编译目标中的任何Swift文件中使用如下语法导入框架：</p> <div class="language-swift extra-class"><pre class="language-swift"><code><span class="token keyword">import</span> <span class="token builtin">FrameworkName</span>
</code></pre></div><p>你可以在其他编译目标中的任何Objective-C的<code>.m</code>文件中使用如下语法导入框架：</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token operator">@</span>import FrameworkName<span class="token punctuation">;</span>
</code></pre></div><table><tr><td> </td><td><strong>导入至Swift</strong></td><td>导入至Objecitve-C</td></tr> <tr><td>任何语言编写的框架</td><td><code>import FrameworkName</code></td><td><code>@import FrameworkName;</code></td></tr></table> <h3 id="在objective-c中使用swift"><a href="#在objective-c中使用swift" class="header-anchor">#</a> 在Objective-C中使用Swift</h3> <p>当你把Swift导入Objective-C之后，你就可以常规的Objective-C的语法来操作Swift类了。</p> <div class="language-objc extra-class"><pre class="language-objc"><code>MySwiftClass <span class="token operator">*</span>swiftObject <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>MySwiftClass alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>swiftObject swiftMethod<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>Swift类或协议必需使用<code>@objc</code>注解标记，才能在Objective-C中访问。这个注解告诉编译器这段Swift代码可以在Objective-C中访问。如果Swift类是派生自Objective-C类，编译器会自动为你给它加上<code>@objc</code>注解。要了解更多信息，请参考<a href="./2_%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7.markdown#swift%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7">Swift类型的兼容性</a>。</p> <p>你可以访问用<code>@objc</code>注解标记的类或协议中的一切，只要它与Objective-C兼容。除了下面列出的这些Swift特有的特性：</p> <ul><li>泛型</li> <li>元组（tuple）</li> <li>在Swift中定义，不是以<code>Int</code>作为原始值类型的枚举</li> <li>Swift中定义的结构体</li> <li>Swift中定义的顶层函数</li> <li>Swift中定义的全局变量</li> <li>Swift中定义的类型别名（typealias）</li> <li>Swift风格的变长参数（variadics）</li> <li>嵌套类型</li> <li>匿名函数（curried functions）</li></ul> <p>例如，接受泛型参数的方法或者返回元组的方法是不能在Objective-C中使用的。</p> <blockquote><p><strong>提示</strong></p> <p>你不能在Objective-C中创建Swift类的子类。</p></blockquote> <h4 id="在objective-c头文件中引用swift的类和协议"><a href="#在objective-c头文件中引用swift的类和协议" class="header-anchor">#</a> 在Objective-C头文件中引用Swift的类和协议</h4> <p>为了避免循环引用，不要在Objective-C的头文件（<code>.h</code>）中导入Swift代码。你可以在Objective-C的接口中使用预声明（forward declare）来引用Swift的类和协议。</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token comment">// MyObject.h</span>
<span class="token keyword">@class</span> MySwiftClass
<span class="token operator">@</span>protocal MySwiftProtocal

<span class="token keyword">@interface</span> MyObjcClass <span class="token punctuation">:</span> NSObject
<span class="token operator">-</span> <span class="token punctuation">(</span>MySwiftClass <span class="token operator">*</span><span class="token punctuation">)</span>returnSwiftClassInstance<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token operator">&lt;</span>MySwiftProtocal<span class="token operator">&gt;</span><span class="token punctuation">)</span>returnInstanceAdoptingSwiftProtocal<span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token keyword">@end</span>
</code></pre></div><p>预声明的Swift类和协议只能用在方法和属性的声明中。</p> <h4 id="在objective-c实现中接受swift的协议"><a href="#在objective-c实现中接受swift的协议" class="header-anchor">#</a> 在Objective-C实现中接受Swift的协议</h4> <p>通过导入Xcode生成的Swift代码的头文件，并使用类扩展（class extension），Objective-C的类可以在其实现（<code>.m</code>）文件中接受Swift的协议。</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token comment">// MyObjcClass.m</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">&quot;ProductModuleName-Swift.h&quot;</span></span>

<span class="token keyword">@interface</span> <span class="token function">MyObjcClass</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>MySwiftProtocal<span class="token operator">&gt;</span>
<span class="token comment">// ...</span>
<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> MyObjcClass
<span class="token comment">// ...</span>
<span class="token keyword">@end</span>
</code></pre></div><h3 id="覆盖objective-c接口中的swift名字"><a href="#覆盖objective-c接口中的swift名字" class="header-anchor">#</a> 覆盖Objective-C接口中的Swift名字</h3> <p>Swift编译器会自动把Objective-C代码自动导入为常规的Swift代码。它会把Objective-C类的工厂方法导入为Swift的构造方法，截断Objective-C的枚举类型值的名字。</p> <p>可能有极少数的情况下，你的代码会无法自动处理。如果你需要修改导入Swift的Objective-C的方法，枚举值，或者选项组的值的名字，你可以使用<code>NS_SWIFT_NAME</code>宏自定义如何导入声明。</p> <h4 id="类的工厂方法"><a href="#类的工厂方法" class="header-anchor">#</a> 类的工厂方法</h4> <p>如果Swift编译器未能识别类的工厂方法，你可以使用<code>NS_SWIFT_NAME</code>宏，传入Swift构造方法的签名，以使之被正确导入。例如：</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token operator">+</span> <span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>recordWithRPM<span class="token punctuation">:</span><span class="token punctuation">(</span>NSUInteger<span class="token punctuation">)</span>RPM <span class="token function">NS_SWIFT_NAME</span><span class="token punctuation">(</span><span class="token function">init</span><span class="token punctuation">(</span>RPM<span class="token punctuation">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果Swift编译器错误地把一个方法认作了类的工厂方法，你也可以使用<code>NS_SWIFT_NAME</code>宏，传入Swift的方法签名，以使之被正确导入。例如：</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token operator">+</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>recordWithQuality<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>quality <span class="token function">NS_SWIFT_NAME</span><span class="token punctuation">(</span><span class="token function">record</span><span class="token punctuation">(</span>quality<span class="token punctuation">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="枚举"><a href="#枚举" class="header-anchor">#</a> 枚举</h4> <p>默认情况下，Swift在导入枚举类型时会截断枚举值名字的前缀。要自定枚举值的名字，你可以使用<code>NS_SWIFT_NAME</code>宏，传入Swift枚举值的名字。例如：</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token keyword">typedef</span> <span class="token function">NS_ENUM</span><span class="token punctuation">(</span>NSInteger<span class="token punctuation">,</span> ABCRecordSide<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ABCRecordSideA<span class="token punctuation">,</span>
	ABCRecordSideB <span class="token function">NS_SWIFT_NAME</span><span class="token punctuation">(</span>FlipSide<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="使objective-c的接口在swift中不可用"><a href="#使objective-c的接口在swift中不可用" class="header-anchor">#</a> 使Objective-C的接口在Swift中不可用</h3> <p>部分Objective-C的接口可能不适合或不需要暴露给Swift。要防止Objective-C的声明被导入Swift，可以使用<code>NS_SWIFT_UNAVAILABLE</code>宏，并传一个引导API使用者使用可能的替代方案的消息给它。</p> <p>比如，Objective-C类提供了一个接受一系列键值对作为变长参数的快捷构造方法。这种情况就可以建议Swift的使用者使用字典字面量代替：</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token operator">+</span> <span class="token punctuation">(</span>instancetype<span class="token punctuation">)</span>collectionWithValues<span class="token punctuation">:</span><span class="token punctuation">(</span>NSArray <span class="token operator">*</span><span class="token punctuation">)</span>values forKeys<span class="token punctuation">:</span><span class="token punctuation">(</span>NSArray<span class="token operator">&lt;</span>NSCopying<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token punctuation">)</span>keys <span class="token function">NS_SWIFT_UNAVAILABLE</span><span class="token punctuation">(</span><span class="token string">&quot;Use a dictionary literal instead&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>试图在Swift代码中调用<code>+collectionWithValues:forKeys:</code>方法会产生一个编译错误。</p> <h3 id="改进objective-c的声明"><a href="#改进objective-c的声明" class="header-anchor">#</a> 改进Objective-C的声明</h3> <p>你可以对Objective-C的方法声明使用<code>NS_REFINED_FOR_SWIFT</code>宏，并在一个扩展中提供一个改进的Swift接口，原始实现在改进的接口中可被调用。例如，一个接受多于一个指针参数的Objective-C方法可以在Swift中改进为返回一个元组值。</p> <ul><li>构造方法在导入Swift时，在第一个外置参数名前加上了双下划线（<code>__</code>）前缀。</li> <li>只要下标方法或赋值方法的任意一个使用了<code>NS_REFINED_FOR_SWIFT</code>标记，对象的下标取值方法就会被导入成Swift的方法，方法名是添加了双下划线（<code>__</code>）前缀的基本名，而不是Swift的下标（subscript）。</li> <li>其他方法会被导入为名字前加上了双下划线（<code>__</code>）的方法。</li></ul> <p>对于下面这个Objective-C声明：</p> <div class="language-objc extra-class"><pre class="language-objc"><code><span class="token keyword">@interface</span> Color <span class="token punctuation">:</span> NSObject

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>getRed<span class="token punctuation">:</span><span class="token punctuation">(</span>nullable CGFloat <span class="token operator">*</span><span class="token punctuation">)</span>red
		 green<span class="token punctuation">:</span><span class="token punctuation">(</span>nullable CGFloat <span class="token operator">*</span><span class="token punctuation">)</span>green
		  blue<span class="token punctuation">:</span><span class="token punctuation">(</span>nullable CGFloat <span class="token operator">*</span><span class="token punctuation">)</span>blue
		 aplha<span class="token punctuation">:</span><span class="token punctuation">(</span>nullable CGFloat <span class="token operator">*</span><span class="token punctuation">)</span>alpha NS_REFINED_FOR_SWIFT<span class="token punctuation">;</span>
<span class="token keyword">@end</span>
</code></pre></div><p>现在，你就可以在扩展中提供一个改进的Swift接口了，如下：</p> <div class="language-swift extra-class"><pre class="language-swift"><code><span class="token keyword">extension</span> <span class="token builtin">Color</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> <span class="token constant">RGBA</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>red<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span><span class="token punctuation">,</span> green<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span><span class="token punctuation">,</span> blue<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span><span class="token punctuation">,</span> alpha<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">var</span> r<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span> <span class="token operator">=</span> <span class="token number">0.0</span>
		<span class="token keyword">var</span> g<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span> <span class="token operator">=</span> <span class="token number">0.0</span>
		<span class="token keyword">var</span> b<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span> <span class="token operator">=</span> <span class="token number">0.0</span>
		<span class="token keyword">var</span> a<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span> <span class="token operator">=</span> <span class="token number">0.0</span>
		<span class="token function">__getRed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">,</span> green<span class="token punctuation">:</span> <span class="token operator">&amp;</span>g<span class="token punctuation">,</span> blue<span class="token punctuation">:</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> alpha<span class="token punctuation">:</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>red<span class="token punctuation">:</span> r<span class="token punctuation">,</span> green<span class="token punctuation">:</span> g<span class="token punctuation">,</span> blue<span class="token punctuation">:</span> b<span class="token punctuation">,</span> alpha<span class="token punctuation">:</span> a<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="给产品模块命名"><a href="#给产品模块命名" class="header-anchor">#</a> 给产品模块命名</h3> <p>Xcode为Swift代码生成的头文件的名字、以及Xcode为你创建的Objective-C桥接头文件的名字，是根据产品模块的名字生成的。默认情况下，产品模块名和产品名是一样的。不过如果产品名包含了非字母和数字字符，例如英文句号（<code>.</code>），在产品模块名中它们会被替换成下划线（<code>_</code>）。如果名字以数字开头，那么第一个数字也会被替换成下划线。</p> <p>你也可以给产品模块名提供一个自定义的名字。Xcode会用它命名桥接头文件和生成的头文件。要修改产品模块名，你只需修改构建设置（Build Settings）中Product Module Name参数的值。</p> <blockquote><p><strong>提示</strong></p> <p>你不能覆盖框架的产品模块名。</p></blockquote> <h3 id="问题诊断和注意事项"><a href="#问题诊断和注意事项" class="header-anchor">#</a> 问题诊断和注意事项</h3> <ul><li>把Swift和Objective-C的文件看作是同一组代码，注意命名是否有冲突。</li> <li>如果你在编写框架，请确保构建设置（Build Settings）的Packageing部分的Define Module（<code>DEFINE_MODULE</code>）参数的值为“YES”。</li> <li>如果需要使用Objective-C的桥接头文件，请确保构建设置（Build Settings）的Swift Compiler - Code Generation部分的Objective-C Bridging Header（<code>SWIFT_OBJC_BRIDGING_HEADER</code>）参数的值被设置为桥接头文件在项目中的相对路径（如，“MyApp/MyApp-Bridging-Header.h”）。</li> <li>Xcode在命名Objective-C桥接头文件和Swift代码的生成的头文件时，使用的是产品模块名（<code>PRODUCT_MODULE_NAME</code>），而不是编译目标名（<code>TARGET_NAME</code>）。要了解更多关于产品模块命名的信息，请参阅<a href="#%E7%BB%99%E4%BA%A7%E5%93%81%E6%A8%A1%E5%9D%97%E5%91%BD%E5%90%8D">给产品模块命名</a>章节。</li> <li>要在Objective-C中可以访问和使用，Swift类必需派生自一个Objective-C类或者必须使用<code>@objc</code>标记。</li> <li>当你把Swift代码导入到Objective-C中时，请牢记，Objective-C无法转译部分Swift特有的特性。要查看这个列表，请查看<a href="#%E6%8A%8Aswift%E5%AF%BC%E5%85%A5objective-c">把Swift导入Objective-C</a>章节。</li> <li>如果你在Swift代码中使用了你自己创建的的Objective-C类，那么请确保在Objective-C的<code>.m</code>文件导入Swift生成的头文件之前，先导入自定义类型的Objective-C头文件。</li> <li>使用<code>private</code>修饰符标记的声明不会出现在生成的头文件中。除非显式地使用<code>@IBAction</code>，<code>@IBOutlet</code>或<code>@objc</code>做了标记，否则私有的声明不会暴露给Objective-C。</li> <li>对于应用编译目标，如果包含了Objective-C的桥接头文件，使用<code>internal</code>修饰符标记的声明会出现在生成的头文件中。</li> <li>对于框架编译目标，只有用<code>public</code>修饰符标记的声明才会出现在框架目标的生成的头文件中。如果Swift的类是派生自Objective-C的类，那么你还可以在框架中的Objective-C中访问用<code>internal</code>修饰符标记的属性和方法。要了解更多关于访问控制修饰符的信息，请参考“Swift编程语言（Swift 2.2版）”的“访问控制”章节。</li></ul> <p><a href="./2_%E4%BA%92%E6%93%8D%E6%80%A7.markdown#%E5%BC%80%E5%A7%8B">&lt; 2. 互操作性</a> | <a href="./0_%E7%9B%AE%E5%BD%95.markdown">目录</a> | <a href="./4_%E8%BF%81%E7%A7%BB%E5%88%B0Swift.markdown">4. 迁移到Swift &gt;</a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/2_互操作性.html" class="prev">
        互操作性
      </a></span> <span class="next"><a href="/4_迁移到Swift.html">
        迁移到Swift
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.852b9951.js" defer></script><script src="/assets/js/2.a9a511c7.js" defer></script><script src="/assets/js/7.db9f1311.js" defer></script>
  </body>
</html>
